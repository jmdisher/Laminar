package com.jeffdisher.laminar.avm;

import java.math.BigInteger;
import java.util.LinkedList;
import java.util.List;
import java.util.UUID;

import org.aion.avm.core.FutureResult;
import org.aion.avm.core.IExternalState;
import org.aion.types.AionAddress;

import com.jeffdisher.laminar.types.event.EventRecord;
import com.jeffdisher.laminar.utils.Assert;


/**
 * Used as the IExternalState passed into the AVM as a "kernel".  Aside from transactions it is given and its internal
 * caches, this is the only access the AVM has to the outside world.
 * This is created for every invocation so it can be specific to the context of each mutation.
 * NOTE:  The AVM concurrent execution cannot be leveraged under this design since the transaction would need to
 * contain more of this information - it isn't really part of the state (things like the value of the input, etc).
 * In the case of Laminar, this is a key area where functionality of AVM is adapted to event store concepts.
 */
public class LaminarExternalStateAdapter implements IExternalState {
	private final TopicContext _context;
	private final List<OutputTuple> _outputList;
	private final long _globalOffset;
	private final byte[] _valueForPut;

	/**
	 * Creates an instance to handle a single mutation execution.
	 * 
	 * @param context The code and data of the contract.
	 * @param globalOffset The global offset of the mutation being executed.
	 * @param valueForPut The value associated with a PUT operation (since only the key can be passed in).
	 */
	public LaminarExternalStateAdapter(TopicContext context, long globalOffset, byte[] valueForPut) {
		_context = context;
		_outputList = new LinkedList<>();
		_globalOffset = globalOffset;
		_valueForPut = valueForPut;
	}

	/**
	 * Called after an invocation has completed to map any results or consequences into things Laminar can interpret.
	 * Blocks for the given executionResult to be populated.
	 * 
	 * @param executionResult The future returned by the AVM which contains the results of the execution.
	 * @param termNumber The term number where the mutation committed.
	 * @param initialLocalOffset The first local offset to apply to any generated events.
	 * @param clientId The client who send the mutation.
	 * @param clientNonce The client's nonce associated with the mutation.
	 * @return The list of EventRecords generated by the transaction or null, if there was failure.
	 */
	public List<EventRecord> createOutputEventRecords(FutureResult executionResult, long termNumber, long initialLocalOffset, UUID clientId, long clientNonce) {
		List<EventRecord> result = null;
		if (executionResult.getResult().transactionStatus.isSuccess()) {
			result = new LinkedList<>();
			long nextLocalOffset = initialLocalOffset;
			for (OutputTuple tuple : _outputList) {
				EventRecord record = (null != tuple.value)
						? EventRecord.put(termNumber, _globalOffset, nextLocalOffset, clientId, clientNonce, tuple.key, tuple.value)
						: EventRecord.delete(termNumber, _globalOffset, nextLocalOffset, clientId, clientNonce, tuple.key);
				nextLocalOffset += 1;
				result.add(record);
			}
		} else {
			// We just return null on failure.
		}
		_outputList.clear();
		return result;
	}

	@Override
	public boolean accountBalanceIsAtLeast(AionAddress arg0, BigInteger arg1) {
		return true;
	}

	@Override
	public boolean accountNonceEquals(AionAddress arg0, BigInteger arg1) {
		return true;
	}

	@Override
	public void adjustBalance(AionAddress arg0, BigInteger arg1) {
	}

	@Override
	public void commit() {
		throw Assert.unreachable("Not Supported");
	}

	@Override
	public void commitTo(IExternalState arg0) {
		throw Assert.unreachable("Not Supported");
	}

	@Override
	public void createAccount(AionAddress arg0) {
		throw Assert.unreachable("Not Supported");
	}

	@Override
	public void deleteAccount(AionAddress arg0) {
		throw Assert.unreachable("Not Supported");
	}

	@Override
	public boolean destinationAddressIsSafeForThisVM(AionAddress arg0) {
		throw Assert.unreachable("Not Supported");
	}

	@Override
	public BigInteger getBalance(AionAddress arg0) {
		return new BigInteger("1000000000");
	}

	@Override
	public BigInteger getBlockDifficulty() {
		return BigInteger.ONE;
	}

	@Override
	public long getBlockEnergyLimit() {
		return 10_000_000L;
	}

	@Override
	public byte[] getBlockHashByNumber(long arg0) {
		throw Assert.unreachable("Not Supported");
	}

	@Override
	public long getBlockNumber() {
		// We will treat the mutation global offset as the "block number".
		return _globalOffset;
	}

	@Override
	public long getBlockTimestamp() {
		return 1L;
	}

	@Override
	public byte[] getCode(AionAddress arg0) {
		return null;
	}

	@Override
	public AionAddress getMinerAddress() {
		return new AionAddress(new byte[AionAddress.LENGTH]);
	}

	@Override
	public BigInteger getNonce(AionAddress arg0) {
		return BigInteger.ZERO;
	}

	@Override
	public byte[] getObjectGraph(AionAddress arg0) {
		return _context.objectGraph;
	}

	@Override
	public byte[] getStorage(AionAddress arg0, byte[] arg1) {
		// A PUT returns the value for any key while a DELETE (or CREATE_TOPIC) returns null for every key.
		return _valueForPut;
	}

	@Override
	public byte[] getTransformedCode(AionAddress arg0) {
		return _context.transformedCode;
	}

	@Override
	public boolean hasAccountState(AionAddress arg0) {
		throw Assert.unreachable("Not Supported");
	}

	@Override
	public boolean hasStorage(AionAddress arg0) {
		return false;
	}

	@Override
	public void incrementNonce(AionAddress arg0) {
	}

	@Override
	public boolean isValidEnergyLimitForCreate(long arg0) {
		return true;
	}

	@Override
	public boolean isValidEnergyLimitForNonCreate(long arg0) {
		return true;
	}

	@Override
	public IExternalState newChildExternalState() {
		throw Assert.unreachable("Not Supported");
	}

	@Override
	public void putCode(AionAddress arg0, byte[] arg1) {
	}

	@Override
	public void putObjectGraph(AionAddress arg0, byte[] arg1) {
		_context.objectGraph = arg1;
	}

	@Override
	public void putStorage(AionAddress arg0, byte[] arg1, byte[] arg2) {
		// Synthesize this as a PUT record (until changes are made to the embedded AVM API to make this a natural thing).
		_outputList.add(new OutputTuple(arg1, arg2));
	}

	@Override
	public void refundAccount(AionAddress arg0, BigInteger arg1) {
		throw Assert.unreachable("Not Supported");
	}

	@Override
	public void removeStorage(AionAddress arg0, byte[] arg1) {
		// Synthesize this as a DELETE record (until changes are made to the embedded AVM API to make this a natural thing).
		_outputList.add(new OutputTuple(arg1, null));
	}

	@Override
	public void setTransformedCode(AionAddress arg0, byte[] arg1) {
		Assert.assertTrue(null == _context.transformedCode);
		_context.transformedCode = arg1;
	}


	private static class OutputTuple {
		public final byte[] key;
		public final byte[] value;
		public OutputTuple(byte[] key, byte[] value) {
			this.key = key.clone();
			this.value = (null != value)
					? value.clone()
					: null;
		}
	}
}
