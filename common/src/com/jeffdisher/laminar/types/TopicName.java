package com.jeffdisher.laminar.types;

import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.regex.Pattern;

import com.jeffdisher.laminar.utils.Assert;


/**
 * A topic is a logical splitting of the global mutation stream such that many mutations may be submitted to a system
 * but a listener will only listen to a single topic.
 * It is an ASCII string of [1..255] characters including numbers, lower-case and capital letters from A-Z, ".", "-",
 * and "-".
 */
public final class TopicName {
	private static final int MAX_NAME_BYTES = 255;
	private static final Pattern ALLOWED_CHARACTERS = Pattern.compile("[a-zA-Z0-9\\.\\_\\-]+");

	/**
	 * Creates a topic from the given string.
	 * 
	 * @param name The string to be made into the TopicName.
	 * @return A new TopicName instance.
	 * @throws IllegalArgumentException if the string contains invalid characters, is less than 1 character or more than
	 * 255 characters.
	 */
	public static TopicName fromString(String name) {
		if (!ALLOWED_CHARACTERS.matcher(name).matches()) {
			throw new IllegalArgumentException("Invalid characters in topic name: " + name);
		}
		byte[] bytes = name.getBytes(StandardCharsets.US_ASCII);
		if (bytes.length > MAX_NAME_BYTES) {
			throw new IllegalArgumentException("Topic name too long: " + name);
		}
		if (0 == bytes.length) {
			throw new IllegalArgumentException("Topics cannot be empty: " + name);
		}
		return new TopicName(bytes);
	}

	/**
	 * The synthetic topic cannot be used by the client but is generated by the server when sending a meta-data message
	 * to a listener, wrapped in a fake EventRecord.
	 * 
	 * @return A synthetic TopicName instance.
	 */
	public static TopicName syntheticTopic() {
		return new TopicName(new byte[0]);
	}

	/**
	 * Deserializes a TopicName from its serialized form in the given ByteBuffer.
	 * 
	 * @param buffer The buffer from which to deserialize the TopicName.
	 * @return A new TopicName instance.
	 */
	public static TopicName deserializeFrom(ByteBuffer buffer) {
		int length = Byte.toUnsignedInt(buffer.get());
		byte[] bytes = new byte[length];
		buffer.get(bytes);
		return new TopicName(bytes);
	}


	/**
	 * The String representation of the TopicName instance, validated against all rules.
	 */
	public final String string;

	private TopicName(byte[] safeBytes) {
		this.string = new String(safeBytes, StandardCharsets.US_ASCII);
		Assert.assertTrue(safeBytes.length == this.string.length());
	}

	/**
	 * @return The size, in bytes, of this instance, when serialized.
	 */
	public int serializedSize() {
		// Just the length byte and the number of characters (all ASCII).
		return Byte.BYTES + this.string.length();
	}

	/**
	 * Serializes the receiver into the given ByteBuffer.
	 * 
	 * @param buffer The ByteBuffer into which the receiver must be serialized.
	 */
	public void serializeInto(ByteBuffer buffer) {
		byte[] bytes = this.string.getBytes(StandardCharsets.US_ASCII);
		buffer.put((byte) bytes.length)
			.put(bytes)
		;
	}

	@Override
	public boolean equals(Object obj) {
		boolean isEqual = false;
		if ((null != obj) && (this.getClass() == obj.getClass())) {
			isEqual = this.string.equals(((TopicName)obj).string);
		}
		return isEqual;
	}

	@Override
	public int hashCode() {
		return this.string.hashCode();
	}

	@Override
	public String toString() {
		return this.string;
	}
}
